# Medarot-P
- Medarot-Pは、ゲームシリーズ「メダロット」のバトルシステム(ロボトル)をPythonでのバイブコーディングで再現する試みです。
- ライブラリとしてPygameを利用しています。

# 開発方針
- **ECSアーキテクチャ (Entity Component System)** を採用し、データとロジックを分離する。
- **Strategyパターン** を積極的に採用し、ゲームルール（スキル、特性、状態異常など）の追加・変更に対して閉じた設計（Open-Closed Principle）を目指す。
- パフォーマンス向上のために行数が増えるような最適化は避ける。

# アーキテクチャ原則
拡張性を最優先とし、Systemが肥大化しないよう、具体的な処理を「Mechanics」に委譲するスタイルを採用。

### 1. Component (`components/`) = 純粋データ
- メソッドを持たず、状態（フィールド）のみを保持するデータクラス。
- `StatusEffect` のような汎用的なリスト構造を活用し、特定のゲームルールに依存したフィールド（例: `stop_timer`）を避ける。

### 2. System (`systems/`) = 進行役・仲介者
- **役割**: ゲームループを回し、Componentを持つEntityをフィルタリングして、適切なMechanicsに処理を委譲する「土管」。
- **原則**: 具体的なゲームルール（「サンダーなら停止する」「ライフルなら...」）をSystem内に記述しない。
- 処理の流れ: `Entity取得` -> `Registryから振る舞いクラスを取得` -> `振る舞いの実行メソッドを呼ぶ`

### 3. Mechanics (`battle/mechanics/`) = ゲームルール・振る舞い
- **役割**: ゲームの具体的なロジック（Strategy/Policy）の実装場所。
- **Registry**: ID（文字列）と振る舞いクラスを紐付けるカタログを持つ。
- ゲームループと独立させた実装により、スキルや特性の追加・変更を容易にする。

### 4. ViewModel / Renderer (`ui/`) = 描画
- **ViewModel**: ECSの世界（Entity/Component）から、描画に必要な情報だけを抽出した「Snapshot（DTO）」を生成する。
- **Renderer**: Pygameへの描画命令のみを行い、ゲームロジックやECSについては一切関知しない。
- この方針によって、将来的に描画機能のみを専用エンジンに乗せ換えることを容易にする。

# ゲームルール概要
- **チーム**: 3vs3の団体戦。リーダー機の頭部破壊で決着。
- **戦闘システム**: 
    - 「コマンド選択 -> 充填(Charge) -> 行動実行 -> 放熱(Cooldown)」のサイクル。
    - スキルによって回避不能や防御不能になるリスクがある。
- **特性と相性**:
    - メダル属性とパーツ属性の一致ボーナス。
    - 攻撃⇔防御間の3すくみ（スピード > パワー > テクニック）による補正。