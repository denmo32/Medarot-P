# Medarot-P
- Medarot-Pは、ゲームシリーズ「メダロット」のバトルシステム(ロボトル)をPythonでのバイブコーディングで再現する試みです。
- ライブラリとしてPygameを利用しています。

# 開発方針
- **ECSアーキテクチャ (Entity Component System)** を採用し、データとロジックを分離する。
- **Strategyパターン** を積極的に採用し、ゲームルール（スキル、特性、状態異常など）の追加・変更に対して閉じた設計（Open-Closed Principle）を目指す。
- パフォーマンス向上のために行数が増えるような最適化は避ける。

# アーキテクチャ原則
拡張性を最優先とし、Systemが肥大化しないよう、具体的な処理を「Mechanics」に委譲するスタイルを採用しています。

### 1. Component (`components/`) = 純粋データ
- メソッドを持たず、状態（フィールド）のみを保持するデータクラス。
- `StatusEffect` のような汎用的なリスト構造を活用し、特定のゲームルールに依存したフィールド（例: `stop_timer`）を避ける。

### 2. System (`systems/`) = 進行役・副作用の実行者
- **役割**: ゲームループを回し、Componentを持つEntityをフィルタリングして、適切なMechanicsに処理を委譲する「土管」。
- **責務**: **副作用（ログ出力、フェーズ遷移、コンポーネントの書き換え）の実行権限を持つ**。
- **原則**: 具体的なゲームルール（「どのような条件で中断すべきか」「ダメージ計算式」など）をSystem内に直接記述せず、Mechanicsに問い合わせる。
- 処理の流れ: `Mechanicsに判断を依頼` -> `結果(boolやメッセージ)を受け取る` -> `Systemがフェーズ遷移やログ追加を実行`

### 3. Mechanics (`battle/mechanics/`) = ゲームルール・判断ロジック
- **役割**: ゲームの具体的なロジック（Strategy/Policy）の実装場所。
- **責務**: 入力を受け取り、判断結果（妥当性、計算結果、メッセージ内容など）を返す。
- **原則**: **副作用（Contextの操作、フェーズ遷移など）を持たない**。純粋関数的な実装を目指し、Systemに結果を返すことに徹する。
- **Registry**: ID（文字列）と振る舞いクラスを紐付けるカタログを持つ。
- **構成**:
    - `skill.py`: 行動（なぐる、がむしゃら等）のルール。
    - `trait.py`: パーツ特性（ライフル、サンダー等）のルール。
    - `status.py`: 状態異常（停止、炎上等）のルール。
    - `combat.py`: 戦闘ダメージ計算の統括。
    - `action.py`: 行動判定ロジック。

### 4. ViewModel / Renderer (`ui/`) = 描画
- **ViewModel**: ECSの世界（Entity/Component）から、描画に必要な情報だけを抽出した「Snapshot（DTO）」を生成する。
- **Renderer**: Pygameへの描画命令のみを行い、ゲームロジックやECSについては一切関知しない。

# ゲームルール概要
- **チーム**: 3vs3の団体戦。リーダー機の頭部破壊で決着。
- **戦闘システム**: 
    - 「コマンド選択 -> 充填(Charge) -> 行動実行 -> 放熱(Cooldown)」のサイクル。
    - スキルに応じて回避不能や防御不能になるリスクがある。
- **特性と相性**:
    - メダル属性とパーツ属性の一致ボーナス。
    - 3すくみ（スピード > パワー > テクニック）による補正。