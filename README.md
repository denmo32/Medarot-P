# Medarot-P
- Medarot-Pは、ゲームシリーズ「メダロット」のバトルシステム(ロボトル)をPythonでのバイブコーディングで再現する試みです。
- ライブラリとしてPygameを利用しています。

# 開発方針
- **ECSアーキテクチャ (Entity Component System)** を採用し、データとロジックを分離する。
- **Strategyパターン** を積極的に採用し、ゲームルール（スキル、特性、状態異常など）の追加・変更に対して閉じた設計（Open-Closed Principle）を目指す。
- パフォーマンス向上のために行数が増えるような最適化は避ける。

# アーキテクチャ原則
拡張性を最優先とし、Systemが肥大化しないよう、具体的な処理を「Mechanics」に委譲するスタイルを採用しています。

### 1. Component (`components/`) = 純粋データ
- メソッドを持たず、状態（フィールド）のみを保持するデータクラス。
- `StatusEffect` のような汎用的なリスト構造を活用し、特定のゲームルールに依存したフィールド（例: `stop_timer`）を避ける。

### 2. System (`systems/`) = 進行役・仲介者
- **役割**: ゲームループを回し、Componentを持つEntityをフィルタリングして、適切なMechanicsに処理を委譲する「土管」。
- **原則**: 具体的なゲームルール（「サンダーなら停止する」「ライフルなら...」）をSystem内に記述しない。
- 処理の流れ: `Entity取得` -> `Registryから振る舞いクラスを取得` -> `振る舞いの実行メソッドを呼ぶ`

### 3. Mechanics (`battle/mechanics/`) = ゲームルール・振る舞い
- **役割**: ゲームの具体的なロジック（Strategy/Policy）の実装場所。
- **Registry**: ID（文字列）と振る舞いクラスを紐付けるカタログを持つ。
- **構成**:
    - `skill.py`: 行動（なぐる、がむしゃら等）のルール。
    - `trait.py`: パーツ特性（ライフル、サンダー等）のルール。
    - `status.py`: 状態異常（停止、炎上等）のルール。
    - `combat.py`: 戦闘ダメージ計算の統括。
    - `action.py`: 行動判定ロジック。

### 4. ViewModel / Renderer (`ui/`) = 描画
- **ViewModel**: ECSの世界（Entity/Component）から、描画に必要な情報だけを抽出した「Snapshot（DTO）」を生成する。
- **Renderer**: Pygameへの描画命令のみを行い、ゲームロジックやECSについては一切関知しない。

# ゲームルール概要
- **チーム**: 3vs3の団体戦。リーダー機の頭部破壊で決着。
- **戦闘システム**: 
    - 「コマンド選択 -> 充填(Charge) -> 行動実行 -> 放熱(Cooldown)」のサイクル。
    - スキルに応じて回避不能や防御不能になるリスクがある。
- **特性と相性**:
    - メダル属性とパーツ属性の一致ボーナス。
    - 3すくみ（スピード > パワー > テクニック）による補正。